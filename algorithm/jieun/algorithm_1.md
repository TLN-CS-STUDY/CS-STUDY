# 1. 시간 복잡도(Time Complexity)
## 1.1. 시간 복잡도(Time Complexity) 란?
알고리즘의 성능을 나타내는 지표로, n개의 입력 데이터에 대해 알고리즘이 문제를 해결하는데 얼만큼의 시간이 걸리는지를 나타낸 것이다. 시간 복잡도는 낮으면 낮을수록 좋다.

## 1.2. 시간 복잡도 표기법
- Big-Ω Notation: 하한 점근 (최상의 경우)
- Big-θ Notation: 최상과 최악의 평균 (평균의 경우)
- Big-O Notation: 상한 점근 (최악의 경우)

Big-O 표기법은 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있기에 자주 사용된다. <br>
최소한의 시간 또는 평균적인 시간을 고려하는 것보다 최악의 경우의 시간을 고려해야 그에 맞는 대응이 가능하다. <br>

## 1.3. 빅오 표기법(Big-O)
빅오 표기법은 불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적으로 사용된다. <br>
연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 나타낸다.
- [fast] O(1) < O(lon n) < O(n) < O(n^2) < O(2n)

<img width="1280" height="856" alt="Image" src="https://github.com/user-attachments/assets/de5c1d0c-9583-4b1d-baac-75afcc8fee0d" />

- 시간 복잡도는 입력된 N의 크기에 따라 실행되는 조작의 수를 나타낸다.
- 공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리의 양을 나타낸다.

#### O(1)
일정한 복잡도(Constant Complexity)라고 하며, 입력 값이 증가하더라도 시간은 늘어나지 않는다. 입력 값의 크기와 관계없이, 즉시 출력값을 얻어 낼 수 있다.

#### O(log n)
로그 복잡도(Logarithmic Complexity)라고 부르며, Big-O 표기법 중 O(1) 다음으로 빠른 시간 복잡도를 가진다.

#### O(n) 
선형 복잡도(Linear Complexity)라고 부르며, 입력 값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것을 의미한다. <br>

#### O(n^2)
2차 복잡도(Quadratic Complexity)라고 부르며, 입력 값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미한다.

- 입력 값이 1인 경우 1초가 걸리던 알고리즘에 5라는 입력 값을 줬을 대 25초가 된다면, 해당 알고리즘의 시간 복잡도는 O(n^2)이라고 한다.

#### O(2n)
기하급수적 복잡도(Exponential Complexity)라고 부르면, Big-O 표기법 중 가장 느린 시간 복잡도를 가진다.

# 2. Sort
## 2.1. Sort Algorithm 이란?
- 목록 안에 저장된 요소들을 특정 순서대로 재배치하는 알고리즘이다.
- 입력 값은 보통 배열과 같은 데이터 구조이다.
- 흔히 사용하는 순서: 숫자, 사전 순서(A-Z)
- 정렬 방향: 오름차순, 내림차순

## 2.2. 정렬 알고리즘 종류
### 2.2.1. 선택 정렬(Selection Sort)
- 주어진 배열에서 가장 작은 최소값을 찾고 배열의 맨 앞의 값과 위치를 바꾸면서 정렬한다.
- 맨 앞의 값을 제외한 배열로 다시 반복한다.
- **시간 복잡도**
    - 최선, 평균, 최악 모두 O(n^2)으로 동일하다.
- **장점**
    - 구현이 간단하다.
    - 비교 횟수에 비해 교환 횟수가 적기 때문에, 많은 교환이 필요한 상황에서 비교적 효율적이다.

- **단점**
    - 데이터를 하나씩 비교하기 때문에, O(n^2)으로 비효율적이다.
    - 정렬된 상태에서 새로운 데이터가 추가되면 정렬 효율이 좋지 않다.

### 2.2.2. 삽입 정렬(Insertion Sort)
- i 번째 원소를 정렬된 상태의 앞부분과 비교하여 적절한 위치에 삽입하는 방식이다.
- i-1 번째 원소까지는 모두 정렬된 상태여야 하며 i-1 번째부터 0번째까지의 원소와 i 번째 원소를 각각 비교하여 i 번째 원소보다 작은 값이 발견되면 그 위치에 i 번째 원소를 **삽입**한다.
- **시간 복잡도**
    - 역으로 정렬되어 있을 경우, O(n^2)이다.
    - 모두 정렬되어 있는 경우, O(n)이다.
    - 즉, 최선의 경우 O(n), 평균과 최악의 경우 O(n^2)이다.
- **장점**
    - 입력으로 들어오는 배열의 원소가 정렬되어 있을수록 속도가 빠르다.
    - 정렬된 값은 교환이 일어나지 않는다.
- **단점**
    - 평균과 최악의 시간 복잡도가 O(n^2)로 비효율적이다.
    - 배열의 길이가 길어질수록 비효율적이다.

### 2.2.3. 병합 정렬(Merge Sort)
- 배열을 작은 단위로 쪼개어 정렬한 결과를 합치면서 전체를 정렬하는 분할 정복(Divide and Conquer) 방식이다.
- 배열을 왼쪽 절반, 오른쪽 절반으로 분할하며 최소 단위로 쪼갠 후 정렬을 진행한다.
- 쪼갠 영역들을 차례대로 병합(merge)한다.
- **시간 복잡도**
    - 최선, 평균, 최악 모두 O(nlog n)이다.
    - 분할할 때 걸리는 시간은 O(n), 병합할 때 걸리는 시간은 O(n), 레벨의 수가 O(log n)이므로 전체 레벨의 병합에 걸리는 총 시간은 O(nlog n)이다.
- **장점**
    - 항상 일정한 시간 복잡도를 가진다.
- **단점**
    - 정렬을 하는 배열 외의 추가적인 임시 배열(추가적인 메모리)가 필요하다.
    - 정렬하고자 하는 배열의 크기만큼의 추가적인 크기가 요구된다.

### 2.2.4. 퀵 정렬(Quick Sort)
- 분할 정복(Divide and Conquer) 방법을 통한 정렬로, 하나의 Pivot(축)을 정해서 이 pivot보다 작은 값은 왼쪽에 큰 값은 오른쪽에 위치시키는 방법이다.
- 왼쪽과 오른쪽에 해당하는 원소들에 대해 두 배열로 나눈다. -> 분할(Divide)
- 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.- 재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장한다.
- **시간 복잡도**
    - 최선과 평균의 경우 O(nlog n)이다.
    - 최악의 경우(정렬이되어 있는 경우) O(n^2)이다.
- **장점**
    - 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환한다.
    - 한 번 결정된 pivot들이 추후 연산에서 제외되는 특성으로, 시간 복잡도 O(nlog n)이 가지는 다른 정렬 알고리즘과 비교했을 때 가장 빠르다.
    - 새로운 메모리를 추가하지 않고 기존 배열에서 정렬을 수행하여 메모리 오버헤드가 없다.
- **단점**
    - 정렬된 배열에 대해서는 불균형 분할에 의해 오히려 수행 시간이 더 오래 걸린다.

### 2.2.5. 기수 정렬(Radix Sort)

<img width="838" height="347" alt="Image" src="https://github.com/user-attachments/assets/da6d649a-ec45-4ee5-aa68-b7479222f109" />

- 데이터의 각 자릿수를 낮은 자릿수에서부터 가장 큰 자릿수까지 올라가면서 정렬을 수행하는 방식이다.
    - 먼저, 최대 자릿수를 구한다.
    - Bucket 배열을 하나 만들어 일의 자리가 같은 원소들을 생성한 배열에 모은다.
    - 1, 10, 100, ..., 최대 자릿수까지 이를 반복한다.
- 비교 연산을 수행하지 않아 조건이 맞는 상황에서 빠른 정렬 속도를 보장한다.
- **시간 복잡도**
    - O(dn)이다.
    - d는 데이터들의 최대 자릿수를 의미한다.
- **장점**
    - 비교없는 O(n)의 시간 복잡도를 가진다.
    - 문자열, 정수 정렬이 가능하다.
- **단점**
    - 자릿수가 없는 것은 정렬할 수 없다.(부동 소수점)
    - 중간 결과를 저장할 bucket 공간이 필요하다.

# 3. Search
## 3.1. Search Algorithm 이란?
- 탐색이란 주어진 데이터 집합에서 원하는 데이터를 찾는 과정이다.
- 탐색 알고리즘은 탐색 작업을 효율적으로 수행할 수 있도록 설계된 알고리즘이다. 

## 3.2. 탐색 알고리즘 종류
### 3.2.1. 선형 탐색 알고리즘(Linear Search Algorithm)

<img width="827" height="480" alt="Image" src="https://github.com/user-attachments/assets/6dbec1cc-b9b9-42b2-89f7-0a8ef67c343c" />

- 데이터의 처음부터 끝까지 모든 요소를 차례대로 비교하여 원하는 데이터를 찾는 알고리즘이다.
- **시간 복잡도**: O(n)
- **특징**
    - **순차적 탐색**: 시작 위치에서 끝까지 모든 요소를 일관된 방법으로 탐색한다.
    - **정렬 불필요**: 데이터가 정렬되어 있지 않아도 사용할 수 있어 초기 데이터 전처리가 필요하지 않다.
    - **구현의 단순성**: 코드가 간단하고 직관적이다.

### 3.2.2. 이진 탐색 알고리즘(Binary Search Algorithm)

<img width="826" height="384" alt="Image" src="https://github.com/user-attachments/assets/b61da13f-f1d9-4351-aaba-223bcff92699" />

- 이미 정렬된 데이터에서 사용할 수 있는 탐색 알고리즘이다.
- 탐색 범위를 1/2씩 줄여나가는 방식이라 이진 탐색 또는 이분 탐색이라고 한다.
- 전체 배열의 중앙을 비교하여 찾으려 하는 값이 작으면 왼쪽, 크면 오른쪽에서부터 다시 탐색하는 방법이다.
- **시간 복잡도**: O(log n)
- **특징**
    - **분할 정복 방식**: 탐색 범위를 계속해서 절반으로 줄여 나가는 방식으로, 탐색 범위를 좁혀가므로 탐색 속도가 빠르다.
    - **정렬된 데이터 필요**: 데이터가 정렬된 상태에서만 사용할 수 있다.
    - **효율성**: 데이터 양이 증가할수록 선형 탐색보다 훨씬 빠른 속도를 보장한다.

## 3.3. 그래프 탐색(Graph Search)
그래프를 탐색한다는 것은 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것을 말한다.

### 3.3.1. 깊이 우선 탐색(DFS, Depth-First Search)
- 최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동한다.
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.

### 3.3.2. 너비 우선 탐색(BFS, Breadth-First Search)
- 최대한 넒게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동한다.
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.
- 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.

**시간 복잡도**
https://wikidocs.net/223073 <br>
https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/ <br>

**Sort**
https://velog.io/@chappi/series/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 <br>
https://east-star.tistory.com/10 <br>

**Search**
https://zerobin-dev.tistory.com/140 <br>
https://bba-dda.tistory.com/21 <br>

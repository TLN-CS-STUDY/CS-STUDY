# 1. 다익스트라 알고리즘(Dijkstra Algorithm)
## 1.1. 다익스트라 알고리즘(Dijkstra Algorithm) 이란?
- 하나의 시작점으로부터 다른 모든 정점까지의 최단 경로(가장 짧은 경로, 최소 비용)를 구하는 알고리즘이다.
- 음의 가중치가 없을 때만 사용이 가능하다.

## 1.2. 동작 단계
1. 출발 노드 지정
2. 출발 노드를 기준으로 각 노드의 최소 비용 저장
3. 방문하지 않은 노드 중 최소 비용 노드 선택
4. 해당 노드에서 특정 노드까지 고려하여 최소 비용 갱신
5. 위의 과정 3-4번 반복

## 1.3. 동작 예

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/1e10f650-6eec-4705-88e3-d3b0e75954ae" />

다익스트라 알고리즘에서는 시작 노드부터 점차 가중치를 더해 다른 노드로 방문하는 순서를 거치게 된다. 그 과정에서 각 노드를 방문했을 때 거쳐온 간선들의 가중치 최소 합을 메모리에 갱신해줘야 한다. <br>

**Step 1)** 1번 노드에서 다른 정점으로 가는 최소 비용을 비교했을 때, 현재 방문하지 않은 노드 중 가장 비용이 적은 노드는 4번 노드이다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/34541c3f-01cc-4a80-8699-04c5b93e7d76" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 5 | 1 | inf | inf |
| 방문 | O | X | X | X | X | X |

**Step 2)** 4번 노드를 거쳐서 가는 경우를 고려했을 때,
5번 노드로 가는 최소 비용을 `inf > 2`로, 3번 노드로 가는 최소 비용을 `5 > 4`로 갱신해준다. <br>
방문하지 않은 노드 중에서 가장 비용이 적은 노드는 2번 노드이다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/0fed7a68-7d9d-4376-bbbe-804d9a063428" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 4 | 1 | 2 | inf |
| 방문 | O | X | X | O | X | X |

**Step 3)** 2번 노드를 거쳐가는 경우 비용이 갱신되지 않아 배열을 그대로 유지한다. <br>
방문하지 않은 노드 중 가장 비용이 적은 노드는 5번 노드이다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/51f3f7ae-9fd9-4b9e-88b7-5cb929eec5f0" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 4 | 1 | 2 | inf |
| 방문 | O | O | X | O | X | X |

**Step 4)** 5번 노드를 거쳐서 가는 경우를 고려했을 때,
6번 노드로 가는 최소 비용을 `inf > 4`로, 3번 노드로 가는 최소 비용을 `4 > 3`으로 갱신해준다. <br>
방문하지 않은 노드 중 가장 비용이 적은 노드는 3번 노드이다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/8793b031-800c-47d0-adde-bb7b2d587ba1" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 3 | 1 | 2 | 4 |
| 방문 | O | O | X | O | O | X |

**Step 5)** 3번 노드를 거쳐가는 경우 최소 비용 갱신은 발생하지 않는다. <br>
마지막 남은 6번 노드를 방문한다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/184c44c1-f4d4-4fa4-bb1a-423facd51152" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 3 | 1 | 2 | 4 |
| 방문 | O | O | O | O | O | X |

**Step 7)** 6번 노드를 거쳐가는 경우 최소 비용 갱신은 발생하지 않는다.

<img width="350" height="656" alt="Image" src="https://github.com/user-attachments/assets/3440ad05-d6d2-4222-b939-b40be7299ddc" />

**최소 비용 배열**
| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| 거리 | 0 | 2 | 3 | 1 | 2 | 4 |
| 방문 | O | O | O | O | O | O |

## 1.3. 구현 방법
### 1.3.1. 순차 탐색
방문하지 않은 노드 중 거리값이 가장 작은 노드를 다음 탐색 노드로 선택한다. 이 노드를 찾는 방식이 순차 탐색이 된다. 노드의 개수가 N이라고 할 때 각 노드마다 최소 거리값을 찾기 위해 순차 탐색이 수행되므로 O(N^2)의 시간이 걸린다.

### 1.3.2. 우선 순위 큐
거리 값을 담을 우선 순위 큐는 힙으로 구현할 때, 최소 힙으로 구현한다면 루트 노드가 최소 거리를 가지는 노드가 될 것이다. <br>
우선 순위 큐에서 사용할 '우선 순위' 기준은 '시작 노드로부터 가장 가까운 노드'가 된다. 따라서 큐의 정렬은 최단 거리를 가지는 노드를 앞에 배치한다. <br>
우선 순위 큐는 최단 거리의 노드를 앞으로 정렬하므로 순차 탐색처럼 방문 여부를 기록할 필요가 없다. 우선 순위 큐에 삽입되는 형태는 `<거리, 노드>` 형태이다.

* * *

# 2. 크루스칼(Kruskal)과 프림(Prim)
## 2.1. 신장 트리(Spanning Tree) 란?
- 그래프 내의 모든 정점을 포함하는 트리로, 최소의 간선으로 모든 정점이 연결되어 있는 순환성이 없는 부분 그래프이다.

#### 최소 신장 트리(Minimum Spanning Tree, MST) 란?
- 그래프 내의 여러 신장 트리 중 가중치가 최소가 되는 신장 트리를 말하며, 최소 신장 트리 알고리즘은 그래프 내의 최소 신장 트리를 찾는 알고리즘이다.
- 크루스칼 알고리즘(Kruskal Algorithm)과 프림 알고리즘(Prim Algorithm)이 대표적이다.

* * *

## 2.2. 크루스칼 알고리즘(Kruskal Algorithm) 이란?
- 그래프에서 간선을 하나씩 추가하며 최소 신장 트리(MST)를 만드는 방식의 알고리즘이다.
- 간선을 추가할 때는 선택 당시 가중치가 최소인 간선을 선택한다.
- 간선 중심의 알고리즘이다.

### 2.2.1. 동작 과정
1. 간선을 가중치 기준으로 오름차순 정렬한다.
2. 간선을 순차적으로 순회하며 최소 신장 트리를 만든다. 이때, 트리에 순환성이 생기지 않는 간선만 추가한다.
3. 최소 신장 트리가 될 때까지 2번 과정을 반복한다.

### 2.2.2. 동작 예

<img width="350" height="364" alt="Image" src="https://github.com/user-attachments/assets/c603822d-d62b-42a6-9510-241e29176d02" />

노드 6개와 간선 8개로 구성된 그래프의 간선의 가중치 기준으로 오름차순 정렬과 부모 테이블이다. <br>
부모 테이블의 초기 값은 노드 자기 자신으로 두고 간선의 가중치가 작은 순서대로 확인하면 된다. <br>

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | (1,2) | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 2 | 3 | 4 | 5 | 6 |

**Step 1)** 가중치가 가장 작은 `(3,6)`을 살펴보면, 노드 3과 6의 부모 노드가 다르기 때문에 사이클이 발생하지 않아 노드 6의 부모를 노드 3으로 갱신해준다.(일반적으로 부모 노드는 작은 노드 번호 기준으로 갱신한다.)

<img src="https://github.com/user-attachments/assets/46c89906-0ad8-4e65-a377-129daf6f041e" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | (1,2) | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 2 | 3 | 4 | 5 | 6 -> 3 |

**Step 2)** 다음으로 가중치가 작은 간선 `(2,3)`을 살펴보면, 노드 2와 3의 부모 노드가 다르기 때문에 사이클이 발생하지 않아 노드 3의 부모를 노드 2로 갱신해준다. <br>
이때 노드 6도 부모 노드를 3으로 가지는 종속 관계이므로 부모 노드를 같이 갱신해준다. <br>

<img src="https://github.com/user-attachments/assets/f812bec0-b252-475b-a36a-1d4ea225b9ed" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | (1,2) | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 2 | 3 -> 2 | 4 | 5 | 3 -> 2 |

**Step 3)** 다음으로 간선 `(1,3)`을 살펴보면, 노드 1과 3의 부모 노드가 다르기 때문에 사이클이 발생하지 않아 노드 3의 부모 노드를 노드 1로 갱신해준다. <br>
이때 종속 관계를 가지는 노드들 또한 같이 갱신해준다.

<img src="https://github.com/user-attachments/assets/03390c9d-3a0b-4a49-b385-44abe14bd6e0" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | (1,2) | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 2 -> 1 | 2 -> 1 | 4 | 5 | 2 -> 1 |

**Step 4)** 다음으로 간선 `(2,4)`를 살펴보면, 노드 2와 4의 부모 노드가 다르기 때문에 사이클이 발생하지 않아 노드 4의 부모 노드를 노드 1로 갱신해준다. <br>

<img src="https://github.com/user-attachments/assets/951606b9-ee3a-4de9-9add-4a3f9f79b345" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | (1,2) | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 1 | 1 | 4 -> 1 | 5 | 1 |

**Step 5)** 다음으로 간선 `(1,2)`를 살펴보면, 노드 1과 2의 부모 노드가 동일하여 사이클이 발생하기 때문에 최소 신장 트리에 포함시키지 않고, 갱신 또한 해주지 않는다.

<img src="https://github.com/user-attachments/assets/644767cb-9386-4e30-901a-7051d72db49b" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | ~~(1,2)~~ | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 1 | 1 | 1 | 5 | 1 |

**Step 6)** 다음으로 간선 `(2,5)`를 살펴보면, 노드 2와 5의 부모 노드가 다르기 때문에 사이클이 발생하지 않아 노드 5의 부모 노드를 1로 갱신해준다. <br>

<img src="https://github.com/user-attachments/assets/ce3f93af-00f3-47fe-b87d-8f2470235bc0" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | ~~(1,2)~~ | (2,5) | (4,5) | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | 7 | 9 | 11 | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 1 | 1 | 1 | 5 -> 1 | 1 |

**Step 7)** 다음으로 간선 `(4,5)`를 살펴보면, 노드 4와 5의 부모 노드가 동일하여 최소 신장 트리에 포함하지 않고, 갱신하지 않는다.

<img src="https://github.com/user-attachments/assets/61daee8f-4ff8-4002-b99c-b1573a553e4e" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | ~~(1,2)~~ | (2,5) | ~~(4,5)~~ | (5,6) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | ~~7~~ | 9 | ~~11~~ | 12 |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 1 | 1 | 1 | 1 | 1 |

**Step 8)** 다음으로 간선 `(5,6)`의 경우, 노드 5와 6의 부모 노드가 동일하여 최소 신장 트리에 포함하지 않고, 갱신하지 않는다. <br>

<img src="https://github.com/user-attachments/assets/ec5a21c9-e29d-4ced-ac62-9288bc11a63a" width="350" />

| 간선 | (3,6) | (2,3) | (1,3) | (2,4) | ~~(1,2)~~ | (2,5) | ~~(4,5)~~ | ~~(5,6)~~ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 1 | 2 | 5 | 6 | ~~7~~ | 9 | ~~11~~ | ~~12~~ |

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 부모 | 1 | 1 | 1 | 1 | 1 | 1 |

**Step 9)** 최소 신장 트리를 찾는 크루스칼 알고리즘 동작이 종료된 후 확인되는 최소 신장 트리이다.

<img src="https://github.com/user-attachments/assets/ca79e09e-d8c5-4746-b84f-1396c56762bf" width="350" />

### 2.2.3. 특징
- 순환성을 확인하기 위해 서로소 집합 알고리즘을 활용한다. 최소 신장 트리란 최소한의 간선의 수로 연결된 순환성이 없는 부분 그래프이다.
- 그리디 알고리즘을 사용하여 선택 당시 가중치 값이 최소인 간선을 선택하기 때문에 간선을 가중치를 기준으로 오름차순 정렬해야 한다.
	- 그리디 알고리즘: 각 단계에서 가장 최선의 선택을 하는 알고리즘
	
### 2.2.4. 시간 복잡도
크루스칼 알고리즘에서는 정렬, 간선 순회, 서로소 집합 연산이 있다.
- 간선 순회: O(E)
- 서로소 집합 연산: O(1)
- 정렬: O(E logE)

* * *

## 2.3. 프림 알고리즘(Prim Algorithm) 이란?
- 최소 신장 트리(MST) 구현에 사용되는 알고리즘이다.
- 시작 정점에서 정점을 추가해가며 단계적으로 트리를 확장한다.
- 정점 중심의 알고리즘이다.

### 2.3.1. 동작 과정
1. 시작 노드만 MST 집합에 포함된다.
2. 트리 집합에 속한 정점들과 인접한 정점들 중 가장 낮은 가중치의 간선과 연결된 정점에 대한 간선과 정점을 MST 트리 집합에 넣는다. (사이클을 막기 위해 연결된 정점이 이미 트리에 속해있다면 다음 순서를 넣는다.)
3. 2번 과정을 MST 집합의 원소 개수가 그래프의 정점의 개수가 될 때까지 반복한다.  

### 2.3.2. 동작 예

<img width="350" height="278" alt="Image" src="https://github.com/user-attachments/assets/fbee8fd7-0fd7-43e0-9ebf-db2bae2164e3" />

위 그래프의 최소 신장 트리를 프림 알고리즘으로 구하는 과정이다. 시작 정점은 A라 한다.

**Step 1)** A와 인접한 노드 B, C 중 C가 가장 가중치가 낮은 간선으로 연결되어 있으니 C를 집합에 넣고 AC 가중치를 더한다.

<img src="https://github.com/user-attachments/assets/bd37ed98-ec3c-4ec7-9466-9808a652661f" width="350" />


| 노드 | [A, C] |
| :---: | :---: |
| 간선 | [AC] |

**Step 2)** A, C와 인접한 노드 중 가장 가중치가 낮은 간선으로 연결되어 있는 B를 집합에 넣고 CB 가중치를 더한다.

<img src="https://github.com/user-attachments/assets/c4799be6-29c5-46b1-8b55-0ecc9d40f72c" width="350" />

| 노드 | [A, C, B] |
| :---: | :---: |
| 간선 | [AC], [CB] |

**Step 3)** A, B, C와 인접한 노드 중 가장 가중치가 낮은 간선으로 연결되어 있는 D를 집합에 넣고 CD 가중치를 더한다.

<img src="https://github.com/user-attachments/assets/b5ba22db-f995-4d09-96a4-2da6c28139d0" width="350" />

| 노드 | [A, C, B, D] |
| :---: | :---: |
| 간선 | [AC], [CB], [CD] |

**Step 4)** A, B, C, D와 인접한 노드 중 가장 가중치가 낮은 간선으로 연결된 E를 집합에 넣고 DE 가중치를 더한다.

<img src="https://github.com/user-attachments/assets/d34cd19b-f3ac-4998-b6b6-3f654a56e171" width="350" />

| 노드 | [A, C, B, D, E] |
| :---: | :---: |
| 간선 | [AC], [CB], [CD], [DE] |

**Step 5)** A, B, C, D, E와 인접한 노드 중 가장 가중치가 낮은 간선으로 연결된 F를 집합에 넣고 DF 가중치를 더한다.

<img src="https://github.com/user-attachments/assets/773120ac-069e-4ef5-a826-a6ea33400e67" width="350" />

| 노드 | [A, C, B, D, E, F] |
| :---: | :---: |
| 간선 | [AC], [CB], [CD], [DE], [DF] |

트리의 집합에 속한 원소의 개수가 N이 되었으므로 탐색을 중단한다. 탐색 결과 최소 비용은 13으로 확인된다.

### 2.3.3. 시간 복잡도
- 배열: O(N^2)
- 최소  힙: O(Elog n)

# 3. 위상 정렬(Topology Sort)
## 3.1. 위상 정렬(Topology Sort) 란?
- 정렬 알고리즘의 일종으로, 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용하는 알고리즘이다.
- 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것이다.

### 3.1.1. 동작 과정
1. 진입차수가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때까지 다음의 과정을 반복한다.
3. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다.
4. 새롭게 진입 차수가 0이 된 노드를 큐에 삽입한다.

### 3.1.2. 동작 예

<img width="350" height="348" alt="Image" src="https://github.com/user-attachments/assets/53671505-1ef6-4261-80ca-302ef31e2707" />

위 그래프의 최소 신장 트리를 프림 알고리즘으로 구하는 과정이다.

**Step 1)** 진입 차수가 0인 노드 1를 큐에 넣어준다.

<img src="https://github.com/user-attachments/assets/33909fa0-c0f8-4ff6-aba7-85963eb970af" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 1 | 1 | 2 | 1 | 2 | 1 |
| 큐 | 1 |
 
**Step 2)** 큐에 있는 노드 1를 꺼내고 노드 1과 연결된 간선을 제거한다. 이때, 노드 2와 노드 5의 진입 차수가 바뀌게 되므로 큐에 넣어준다.

<img src="https://github.com/user-attachments/assets/b07314ca-9165-4903-8f42-5239bc459383" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 1 | 2 | 0 | 2 | 1 |
| 큐 | 2, 5 |

**Step 3)** 큐에 있는 노드 2를 꺼내고 노드 2와 연결된 간선을 제거한다. 이때, 노드 3의 진입차수가 바뀌게 되므로 큐에 넣어준다.

<img src="https://github.com/user-attachments/assets/5e93f5cf-4e4e-483c-837e-64d08fef7b0e" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 2 | 0 | 1 | 1 |
| 큐 | 5, 3 |

**Step 4)** 큐에 있는 노드 5를 꺼내고 연결된 간선을 제거한다. 이때 노드 6의 진입차수가 바뀌게 되므로 큐에 넣어준다. 

<img src="https://github.com/user-attachments/assets/c70ffb93-ef91-49d9-808b-28ecb792f516" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 2 | 0 | 0 | 1 |
| 큐 | 3, 6 |

**Step 5)** 큐에 있는 노드 3를 꺼내고 연결된 간선을 제거한다. 진입차수가 0이 되는 노드가 없으므로 넘어간다.

<img src="https://github.com/user-attachments/assets/7f7f80ef-7b1c-452b-ab5c-f693d3e9a5e5" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |
| 큐 | 6 |

**Step 6)** 큐에 있는 노드 6를 꺼내고 연결된 간선을 제거한다. 노드 4의 진입차수가 0이 되므로 큐에 넣어준다.

<img src="https://github.com/user-attachments/assets/86379f42-fcac-4dda-8c5f-be08ddc0f6a2" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 큐 | 4 |

**Step 7)** 큐에 있는 노드 4를 꺼내고 연결된 간선을 제거한다. 노드 7의 진입차수가 0이 되므로 큐에 넣어준다.

<img src="https://github.com/user-attachments/assets/d6d17e41-7ae2-4fcd-ab05-ae98308baca6" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 큐 | 7 |

**Step 8)** 큐에 있는 노드 7를 꺼내고 연결된 간선을 제거한다.

<img src="https://github.com/user-attachments/assets/6e82a003-910e-44ac-813c-980b1a6bc329" width="350" />

| 노드 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차수 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 큐 | - |

**[결과]** 1 -> 2 -> 5 -> 3 -> 6 -> 4 -> 7

### 3.1.3. 특징
- 사이클이 없는 방향 그래프(DAG)에서만 수행할 수 있다.
	- DAG (Direct Acyclic Graph): 순환하지 않는(= 사이클이 없는) 방향 그래프
- 위상 정렬에는 여러 가지의 답이 존재할 수 있다.
- 모든 원소를 방문하기 전에 큐가 비게 된다면 사이클이 존재한다고 판단할 수 있다.

### 3.1.4. 시간 복잡도
차례대로 모든 노드를 확인하면서 O(V), 해당 노드에서 출발하는 간선을 차례대로 제거하면서 O(E)가 걸린다. <br>
따라서, 노드와 간선을 모두 확인하는 것을 고려하여 O(V) + O(E) = O(V+E) 시간이 소요된다.

# 4. 깊이 우선 탐색(DFS)와 너비 우선 탐색(BFS)
## 4.1. 깊이 우선 탐색(Depth First Search, DFS) 이란?
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다.
- 재귀 호출이나 스택 자료구조를 사용한다.

### 4.1.1. 동작 과정
1. 탐색 시작점에서 시작하여 한 방향으로 갈 수 있는 끝까지 이동한다.
2. 더 이상 갈 수 없으면 이전 정점으로 돌아와서 아직 방문하지 않은 경로를 탐색한다.
3. 모든 경로를 탐색할 때까지 앞선 과정을 반복한다.

### 4.1.2. 동작 예

<img width="400" height="697" alt="Image" src="https://github.com/user-attachments/assets/e2fd2a4e-ed07-4986-95c5-7b37ec79625c" />

- 시작 노드에서부터 한 경로를 따라 최대한 깊게 탐색한 후, 다른 경로를 탐색한다.

### 4.1.3. 특징
- **메모리 효율성** : 스택을 이용하기 때문에 노드 수에 비해 메모리 사용이 적다.
- **깊이 우선** : 시작점에서 멀리 떨어진 노드를 먼저 탐색하므로, 길이 긴 경로를 선호할 때 유리하다.
- **트리 구조에서의 용도**: DFS는 이진 트리의 순회(전위, 중위, 후위)에 자주 사용된다.

## 4.2. 너비 우선 탐색(Breadth First Search, BFS) 이란?
- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다. 즉, 선입선출(FIFO)를 원칙으로 탐색한다.

### 4.2.1. 동작 과정
1. 탐색 시작점에서 출발하여, 인접한 모든 정점을 큐에 넣고 방문한다.
2. 방문한 정점의 인접한 정점들을 다시 큐에 넣으며 너비를 넓혀간다.
3. 모든 정점을 탐색할 때까지 앞선 과정을 반복한다.

### 4.2.2. 동작 예

<img width="400" height="1120" alt="Image" src="https://github.com/user-attachments/assets/d61be28b-c561-4db3-aba6-c6121d8c6be9" />

- 깊이가 1인 모든 노드를 방문한 후 깊이가 2인 모든  노드를, 그 다음에는 깊이가 3인 모든 노드를 방문하는 식으로 계속 방문하다가 더 이상 방문할 곳이 없으면 탐색을 마친다.


### 4.2.3. 특징
- **최단 경로 탐색** : 무가중치 그래프에서는 출발점에서 특정 정점까지의 최단 경로를 보장한다.
- **메모리 사용** : 큐에 모든 이웃을 저장하기 때문에 메모리 사용량이 많을 수 있다.
- **평행적 확장** : 출발점에서 가까운 정점부터 차례대로 탐색하기 때문에 일정한 깊이에서의 노드를 한 번에 탐색할 수 있다.

## 4.3. DFS vs BFS
|**구분**|**DFS**|**BFS**|
| :---: | :---: | :---: |
|**탐색 방식**| 한 경로를 끝까지 탐색, 재귀적으로 탐색 | 가까운 노드부터 차레로 탐색, 큐 사용 |
|**자료 구조**| 스택(재귀 호출) 사용 | 큐 사용 |
|**메모리**| 메모리 사용 적음 | 메모리 사용 많음 |
|**경로 탐색**| 깊은 경로 선호, 최단 경로 보장하지 않음 | 최단 경로 탐색에 유리 |
|**용도**| 미로 찾기, 백트래킹 문제 | 최단 경로 탐색, 네트워크 탐색 |


* * *
**다익스트라 알고리즘**
https://m.blog.naver.com/ndb796/221234424646 <br>

**크루스칼 알고리즘**
https://velog.io/@sy508011/%EA%B7%B8%EB%9E%98%ED%94%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Kruskal-Algorithm <br>
https://roytravel.tistory.com/348 <br>

**프림 알고리즘**
https://8iggy.tistory.com/159 <br>
https://velog.io/@suk13574/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Java-%ED%94%84%EB%A6%BCPrim-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 <br>

**위상 정렬**
https://velog.io/@kimdukbae/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-Topological-Sorting <br>
https://m.blog.naver.com/ndb796/221236874984 <br>

**DFS / BFS**
https://yunyoung1819.tistory.com/86 <br>
https://dev-yyh.github.io/Algorithm/7 <br>


